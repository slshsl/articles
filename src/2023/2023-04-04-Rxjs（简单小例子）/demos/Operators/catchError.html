<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Document</title>
	</head>
	<body>
		<script src="./rxjs.js"></script>
		<script>
			const { throwError, of, Observable, catchError, map } = rxjs;

			// 发出错误
			const source = throwError('This is an error!');
			// 优雅地处理错误，并返回带有错误信息的 observable
			source
				//记住要在 catch 函数中返回一个 observable !为什么？新版应该没这个限制？
				.pipe(catchError((val) => `I caught: ${val} by catchError`))
				.subscribe((val) => console.log(val));

			// 自己实现的catchError
			const myCatchError = function (project) {
				return function (preObservable) {
					const nextObservable = new Observable((subscriber) => {
						preObservable.subscribe({
							next: (value) => {
								subscriber.next(value);
							},
							complete: () => {
								console.log(123);
								subscriber.complete();
							},
							error: (err) => {
								const temp = project(err);
								if (
									typeof temp === 'object' &&
									typeof temp.subscribe === 'function'
								) {
									temp.subscribe((val) => {
										subscriber.next(val);
									});
								} else {
									subscriber.next(temp);
								}
							}
						});
					});

					return nextObservable;
				};
			};

			source
				.pipe(
					myCatchError((val) => of(`I caught: ${val} by mycatchError`)),
					map((val) => {
						return val + '!!!!!!!!!!!!!!!!!!';
					})
				)
				.subscribe((val) => console.log(val));
		</script>
	</body>
</html>
